{"ast":null,"code":"import assert from './_assert.js';\nimport { toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash, ikm, salt) {\n  assert.hash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash, prk, info, length = 32) {\n  assert.hash(hash);\n  assert.number(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);","map":{"version":3,"names":["assert","toBytes","hmac","extract","hash","ikm","salt","undefined","Uint8Array","outputLen","HKDF_COUNTER","EMPTY_BUFFER","expand","prk","info","length","number","Error","blocks","Math","ceil","okm","HMAC","create","HMACTmp","_cloneInto","T","counter","update","digestInto","set","destroy","fill","slice","hkdf"],"sources":["/Users/lance/myProject/nostr-client-web/node_modules/@noble/hashes/src/hkdf.ts"],"sourcesContent":["import assert from './_assert.js';\nimport { CHash, Input, toBytes } from './utils.js';\nimport { hmac } from './hmac.js';\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nexport function extract(hash: CHash, ikm: Input, salt?: Input) {\n  assert.hash(hash);\n  // NOTE: some libraries treat zero-length array as 'not provided';\n  // we don't, since we have undefined as 'not provided'\n  // https://github.com/RustCrypto/KDFs/issues/15\n  if (salt === undefined) salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n  return hmac(hash, toBytes(salt), toBytes(ikm));\n}\n\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nexport function expand(hash: CHash, prk: Input, info?: Input, length: number = 32) {\n  assert.hash(hash);\n  assert.number(length);\n  if (length > 255 * hash.outputLen) throw new Error('Length should be <= 255*HashLen');\n  const blocks = Math.ceil(length / hash.outputLen);\n  if (info === undefined) info = EMPTY_BUFFER;\n  // first L(ength) octets of T\n  const okm = new Uint8Array(blocks * hash.outputLen);\n  // Re-use HMAC instance between blocks\n  const HMAC = hmac.create(hash, prk);\n  const HMACTmp = HMAC._cloneInto();\n  const T = new Uint8Array(HMAC.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    // T(0) = empty string (zero length)\n    // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n      .update(info)\n      .update(HKDF_COUNTER)\n      .digestInto(T);\n    okm.set(T, hash.outputLen * counter);\n    HMAC._cloneInto(HMACTmp);\n  }\n  HMAC.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\n\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nexport const hkdf = (\n  hash: CHash,\n  ikm: Input,\n  salt: Input | undefined,\n  info: Input | undefined,\n  length: number\n) => expand(hash, extract(hash, ikm, salt), info, length);\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,cAAc;AACjC,SAAuBC,OAAO,QAAQ,YAAY;AAClD,SAASC,IAAI,QAAQ,WAAW;AAEhC;AACA;AAEA;;;;;;;;AAQA,OAAM,SAAUC,OAAOA,CAACC,IAAW,EAAEC,GAAU,EAAEC,IAAY;EAC3DN,MAAM,CAACI,IAAI,CAACA,IAAI,CAAC;EACjB;EACA;EACA;EACA,IAAIE,IAAI,KAAKC,SAAS,EAAED,IAAI,GAAG,IAAIE,UAAU,CAACJ,IAAI,CAACK,SAAS,CAAC,CAAC,CAAC;EAC/D,OAAOP,IAAI,CAACE,IAAI,EAAEH,OAAO,CAACK,IAAI,CAAC,EAAEL,OAAO,CAACI,GAAG,CAAC,CAAC;AAChD;AAEA;AACA,MAAMK,YAAY,GAAG,IAAIF,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;AACxC,MAAMG,YAAY,GAAG,IAAIH,UAAU,EAAE;AAErC;;;;;;AAMA,OAAM,SAAUI,MAAMA,CAACR,IAAW,EAAES,GAAU,EAAEC,IAAY,EAAEC,MAAA,GAAiB,EAAE;EAC/Ef,MAAM,CAACI,IAAI,CAACA,IAAI,CAAC;EACjBJ,MAAM,CAACgB,MAAM,CAACD,MAAM,CAAC;EACrB,IAAIA,MAAM,GAAG,GAAG,GAAGX,IAAI,CAACK,SAAS,EAAE,MAAM,IAAIQ,KAAK,CAAC,iCAAiC,CAAC;EACrF,MAAMC,MAAM,GAAGC,IAAI,CAACC,IAAI,CAACL,MAAM,GAAGX,IAAI,CAACK,SAAS,CAAC;EACjD,IAAIK,IAAI,KAAKP,SAAS,EAAEO,IAAI,GAAGH,YAAY;EAC3C;EACA,MAAMU,GAAG,GAAG,IAAIb,UAAU,CAACU,MAAM,GAAGd,IAAI,CAACK,SAAS,CAAC;EACnD;EACA,MAAMa,IAAI,GAAGpB,IAAI,CAACqB,MAAM,CAACnB,IAAI,EAAES,GAAG,CAAC;EACnC,MAAMW,OAAO,GAAGF,IAAI,CAACG,UAAU,EAAE;EACjC,MAAMC,CAAC,GAAG,IAAIlB,UAAU,CAACc,IAAI,CAACb,SAAS,CAAC;EACxC,KAAK,IAAIkB,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGT,MAAM,EAAES,OAAO,EAAE,EAAE;IACjDjB,YAAY,CAAC,CAAC,CAAC,GAAGiB,OAAO,GAAG,CAAC;IAC7B;IACA;IACAH,OAAO,CAACI,MAAM,CAACD,OAAO,KAAK,CAAC,GAAGhB,YAAY,GAAGe,CAAC,CAAC,CAC7CE,MAAM,CAACd,IAAI,CAAC,CACZc,MAAM,CAAClB,YAAY,CAAC,CACpBmB,UAAU,CAACH,CAAC,CAAC;IAChBL,GAAG,CAACS,GAAG,CAACJ,CAAC,EAAEtB,IAAI,CAACK,SAAS,GAAGkB,OAAO,CAAC;IACpCL,IAAI,CAACG,UAAU,CAACD,OAAO,CAAC;;EAE1BF,IAAI,CAACS,OAAO,EAAE;EACdP,OAAO,CAACO,OAAO,EAAE;EACjBL,CAAC,CAACM,IAAI,CAAC,CAAC,CAAC;EACTtB,YAAY,CAACsB,IAAI,CAAC,CAAC,CAAC;EACpB,OAAOX,GAAG,CAACY,KAAK,CAAC,CAAC,EAAElB,MAAM,CAAC;AAC7B;AAEA;;;;;;;;AAQA,OAAO,MAAMmB,IAAI,GAAGA,CAClB9B,IAAW,EACXC,GAAU,EACVC,IAAuB,EACvBQ,IAAuB,EACvBC,MAAc,KACXH,MAAM,CAACR,IAAI,EAAED,OAAO,CAACC,IAAI,EAAEC,GAAG,EAAEC,IAAI,CAAC,EAAEQ,IAAI,EAAEC,MAAM,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}