{"ast":null,"code":"// Basic utils for salsa-like ciphers\n// Check out _micro.ts for descriptive documentation.\nimport assert from './_assert.js';\nimport { u32, utf8ToBytes, checkOpts } from './utils.js';\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- Original papers don't allow mutating counters\n- Counter overflow is undefined: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n- 3rd-party library stablelib implementation uses an approach where you can provide\n  nonce and counter instead of just nonce - and it will re-use it\n- We could have did something similar, but ChaCha has different counter position\n  (counter | nonce), which is not composable with XChaCha, because full counter\n  is (nonce16 | counter | nonce16). Stablelib doesn't support in-place counter for XChaCha.\n- We could separate nonce & counter and provide separate API for counter re-use, but\n  there are different counter sizes depending on an algorithm.\n- Salsa & ChaCha also differ in structures of key / sigma:\n\n    salsa:     c0 | k(4) | c1 | nonce(2) | ctr(2) | c2 | k(4) | c4\n    chacha:    c(4) | k(8) | ctr(1) | nonce(3)\n    chachaDJB: c(4) | k(8) | ctr(2) | nonce(2)\n- Creating function such as `setSalsaState(key, nonce, sigma, data)` won't work,\n  because we can't re-use counter array\n- 32-bit nonce is `2 ** 32 * 64` = 256GB with 32-bit counter\n- JS does not allow UintArrays bigger than 4GB, so supporting 64-bit counters doesn't matter\n\nStructure is as following:\n\nkey=16 -> sigma16, k=key|key\nkey=32 -> sigma32, k=key\n\nnonces:\nsalsa20:      8   (8-byte counter)\nchacha20djb:  8   (8-byte counter)\nchacha20tls:  12  (4-byte counter)\nxsalsa:       24  (16 -> hsalsa, 8 -> old nonce)\nxchacha:      24  (16 -> hchacha, 8 -> old nonce)\n\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\nUse the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n*/\nconst sigma16 = utf8ToBytes('expand 16-byte k');\nconst sigma32 = utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n// Is byte array aligned to 4 byte offset (u32)?\nconst isAligned32 = b => !(b.byteOffset % 4);\nexport const salsaBasic = opts => {\n  const {\n    core,\n    rounds,\n    counterRight,\n    counterLen,\n    allow128bitKeys,\n    extendNonceFn,\n    blockLen\n  } = checkOpts({\n    rounds: 20,\n    counterRight: false,\n    counterLen: 8,\n    allow128bitKeys: true,\n    blockLen: 64\n  }, opts);\n  assert.number(counterLen);\n  assert.number(rounds);\n  assert.number(blockLen);\n  assert.bool(counterRight);\n  assert.bool(allow128bitKeys);\n  const blockLen32 = blockLen / 4;\n  if (blockLen % 4 !== 0) throw new Error('Salsa/ChaCha: blockLen must be aligned to 4 bytes');\n  return function (key, nonce, data, output) {\n    let counter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    assert.bytes(key);\n    assert.bytes(nonce);\n    assert.bytes(data);\n    if (!output) output = new Uint8Array(data.length);\n    assert.bytes(output);\n    assert.number(counter);\n    // > new Uint32Array([2**32])\n    // Uint32Array(1) [ 0 ]\n    // > new Uint32Array([2**32-1])\n    // Uint32Array(1) [ 4294967295 ]\n    if (counter < 0 || counter >= 2 ** 32 - 1) throw new Error('Salsa/ChaCha: counter overflow');\n    if (output.length < data.length) {\n      throw new Error(\"Salsa/ChaCha: output (\".concat(output.length, \") is shorter than data (\").concat(data.length, \")\"));\n    }\n    const toClean = [];\n    let k, sigma;\n    // Handle 128 byte keys\n    if (key.length === 32) {\n      k = key;\n      sigma = sigma32_32;\n    } else if (key.length === 16 && allow128bitKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else throw new Error(\"Salsa/ChaCha: invalid 32-byte key, got length=\".concat(key.length));\n    // Handle extended nonce (HChaCha/HSalsa)\n    if (extendNonceFn) {\n      if (nonce.length <= 16) throw new Error(\"Salsa/ChaCha: extended nonce must be bigger than 16 bytes\");\n      k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));\n      toClean.push(k);\n      nonce = nonce.subarray(16);\n    }\n    // Handle nonce counter\n    const nonceLen = 16 - counterLen;\n    if (nonce.length !== nonceLen) throw new Error(\"Salsa/ChaCha: nonce must be \".concat(nonceLen, \" or 16 bytes\"));\n    // Pad counter when nonce is 64 bit\n    if (nonceLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      toClean.push(nonce = nc);\n    }\n    // Counter positions\n    const block = new Uint8Array(blockLen);\n    // Cast to Uint32Array for speed\n    const b32 = u32(block);\n    const k32 = u32(k);\n    const n32 = u32(nonce);\n    // Make sure that buffers aligned to 4 bytes\n    const d32 = isAligned32(data) && u32(data);\n    const o32 = isAligned32(output) && u32(output);\n    toClean.push(b32);\n    const len = data.length;\n    for (let pos = 0, ctr = counter; pos < len; ctr++) {\n      core(sigma, k32, n32, b32, ctr, rounds);\n      if (ctr >= 2 ** 32 - 1) throw new Error('Salsa/ChaCha: counter overflow');\n      const take = Math.min(blockLen, len - pos);\n      // full block && aligned to 4 bytes\n      if (take === blockLen && o32 && d32) {\n        const pos32 = pos / 4;\n        if (pos % 4 !== 0) throw new Error('Salsa/ChaCha: invalid block position');\n        for (let j = 0; j < blockLen32; j++) o32[pos32 + j] = d32[pos32 + j] ^ b32[j];\n        pos += blockLen;\n        continue;\n      }\n      for (let j = 0; j < take; j++) output[pos + j] = data[pos + j] ^ block[j];\n      pos += take;\n    }\n    for (let i = 0; i < toClean.length; i++) toClean[i].fill(0);\n    return output;\n  };\n};","map":{"version":3,"names":["assert","u32","utf8ToBytes","checkOpts","sigma16","sigma32","sigma16_32","sigma32_32","isAligned32","b","byteOffset","salsaBasic","opts","core","rounds","counterRight","counterLen","allow128bitKeys","extendNonceFn","blockLen","number","bool","blockLen32","Error","key","nonce","data","output","counter","arguments","length","undefined","bytes","Uint8Array","concat","toClean","k","sigma","set","push","subarray","nonceLen","nc","block","b32","k32","n32","d32","o32","len","pos","ctr","take","Math","min","pos32","j","i","fill"],"sources":["/Users/lance/myProject/nostr-client-web/node_modules/@noble/ciphers/src/_salsa.ts"],"sourcesContent":["// Basic utils for salsa-like ciphers\n// Check out _micro.ts for descriptive documentation.\nimport assert from './_assert.js';\nimport { u32, utf8ToBytes, checkOpts } from './utils.js';\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- Original papers don't allow mutating counters\n- Counter overflow is undefined: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n- 3rd-party library stablelib implementation uses an approach where you can provide\n  nonce and counter instead of just nonce - and it will re-use it\n- We could have did something similar, but ChaCha has different counter position\n  (counter | nonce), which is not composable with XChaCha, because full counter\n  is (nonce16 | counter | nonce16). Stablelib doesn't support in-place counter for XChaCha.\n- We could separate nonce & counter and provide separate API for counter re-use, but\n  there are different counter sizes depending on an algorithm.\n- Salsa & ChaCha also differ in structures of key / sigma:\n\n    salsa:     c0 | k(4) | c1 | nonce(2) | ctr(2) | c2 | k(4) | c4\n    chacha:    c(4) | k(8) | ctr(1) | nonce(3)\n    chachaDJB: c(4) | k(8) | ctr(2) | nonce(2)\n- Creating function such as `setSalsaState(key, nonce, sigma, data)` won't work,\n  because we can't re-use counter array\n- 32-bit nonce is `2 ** 32 * 64` = 256GB with 32-bit counter\n- JS does not allow UintArrays bigger than 4GB, so supporting 64-bit counters doesn't matter\n\nStructure is as following:\n\nkey=16 -> sigma16, k=key|key\nkey=32 -> sigma32, k=key\n\nnonces:\nsalsa20:      8   (8-byte counter)\nchacha20djb:  8   (8-byte counter)\nchacha20tls:  12  (4-byte counter)\nxsalsa:       24  (16 -> hsalsa, 8 -> old nonce)\nxchacha:      24  (16 -> hchacha, 8 -> old nonce)\n\nhttps://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\nUse the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n*/\n\nconst sigma16 = utf8ToBytes('expand 16-byte k');\nconst sigma32 = utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\nexport type SalsaOpts = {\n  core: (\n    c: Uint32Array,\n    key: Uint32Array,\n    nonce: Uint32Array,\n    out: Uint32Array,\n    counter: number,\n    rounds?: number\n  ) => void;\n  rounds?: number;\n  counterRight?: boolean; // counterRight ? nonce | counter : counter | nonce;\n  counterLen?: number;\n  blockLen?: number; // NOTE: not tested with different blockLens!\n  allow128bitKeys?: boolean; // Original salsa/chacha allows these, but not tested!\n  extendNonceFn?: (c: Uint32Array, key: Uint8Array, src: Uint8Array, dst: Uint8Array) => Uint8Array;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nconst isAligned32 = (b: Uint8Array) => !(b.byteOffset % 4);\n\nexport const salsaBasic = (opts: SalsaOpts) => {\n  const { core, rounds, counterRight, counterLen, allow128bitKeys, extendNonceFn, blockLen } =\n    checkOpts(\n      { rounds: 20, counterRight: false, counterLen: 8, allow128bitKeys: true, blockLen: 64 },\n      opts\n    );\n  assert.number(counterLen);\n  assert.number(rounds);\n  assert.number(blockLen);\n  assert.bool(counterRight);\n  assert.bool(allow128bitKeys);\n  const blockLen32 = blockLen / 4;\n  if (blockLen % 4 !== 0) throw new Error('Salsa/ChaCha: blockLen must be aligned to 4 bytes');\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    assert.bytes(key);\n    assert.bytes(nonce);\n    assert.bytes(data);\n    if (!output) output = new Uint8Array(data.length);\n    assert.bytes(output);\n    assert.number(counter);\n    // > new Uint32Array([2**32])\n    // Uint32Array(1) [ 0 ]\n    // > new Uint32Array([2**32-1])\n    // Uint32Array(1) [ 4294967295 ]\n    if (counter < 0 || counter >= 2 ** 32 - 1) throw new Error('Salsa/ChaCha: counter overflow');\n    if (output.length < data.length) {\n      throw new Error(\n        `Salsa/ChaCha: output (${output.length}) is shorter than data (${data.length})`\n      );\n    }\n    const toClean = [];\n    let k, sigma;\n    // Handle 128 byte keys\n    if (key.length === 32) {\n      k = key;\n      sigma = sigma32_32;\n    } else if (key.length === 16 && allow128bitKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else throw new Error(`Salsa/ChaCha: invalid 32-byte key, got length=${key.length}`);\n    // Handle extended nonce (HChaCha/HSalsa)\n    if (extendNonceFn) {\n      if (nonce.length <= 16)\n        throw new Error(`Salsa/ChaCha: extended nonce must be bigger than 16 bytes`);\n      k = extendNonceFn(sigma, k, nonce.subarray(0, 16), new Uint8Array(32));\n      toClean.push(k);\n      nonce = nonce.subarray(16);\n    }\n    // Handle nonce counter\n    const nonceLen = 16 - counterLen;\n    if (nonce.length !== nonceLen)\n      throw new Error(`Salsa/ChaCha: nonce must be ${nonceLen} or 16 bytes`);\n    // Pad counter when nonce is 64 bit\n    if (nonceLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      toClean.push((nonce = nc));\n    }\n    // Counter positions\n    const block = new Uint8Array(blockLen);\n    // Cast to Uint32Array for speed\n    const b32 = u32(block);\n    const k32 = u32(k);\n    const n32 = u32(nonce);\n    // Make sure that buffers aligned to 4 bytes\n    const d32 = isAligned32(data) && u32(data);\n    const o32 = isAligned32(output) && u32(output);\n    toClean.push(b32);\n    const len = data.length;\n    for (let pos = 0, ctr = counter; pos < len; ctr++) {\n      core(sigma, k32, n32, b32, ctr, rounds);\n      if (ctr >= 2 ** 32 - 1) throw new Error('Salsa/ChaCha: counter overflow');\n      const take = Math.min(blockLen, len - pos);\n      // full block && aligned to 4 bytes\n      if (take === blockLen && o32 && d32) {\n        const pos32 = pos / 4;\n        if (pos % 4 !== 0) throw new Error('Salsa/ChaCha: invalid block position');\n        for (let j = 0; j < blockLen32; j++) o32[pos32 + j] = d32[pos32 + j] ^ b32[j];\n        pos += blockLen;\n        continue;\n      }\n      for (let j = 0; j < take; j++) output[pos + j] = data[pos + j] ^ block[j];\n      pos += take;\n    }\n    for (let i = 0; i < toClean.length; i++) toClean[i].fill(0);\n    return output;\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}